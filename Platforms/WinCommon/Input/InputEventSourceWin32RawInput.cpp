#include "InputEventSourceWin32RawInput.hpp"

#include <vector>

#include <Usagi/Module/Platforms/WinCommon/Win32.hpp>
#include <Usagi/Runtime/WeakSingleton.hpp>

#include "VirtualKey.hpp"
#include "RawInputSink.hpp"

namespace usagi::win32
{
// https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-rawmouse#remarks
POINT convert_from_absolute_position(const Vector2f &pos)
{
    const float width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    const float height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    return {
        static_cast<LONG>(pos.x() / USHRT_MAX * width),
        static_cast<LONG>(pos.y() / USHRT_MAX * height)
    };
}
}

namespace usagi
{
bool InputEventSourceWin32RawInput::raw_input__handle_keyboard(
    InputEventInserter &inserter,
    const tagRAWKEYBOARD &keyboard,
    const win32::MessageInfo &info)
{
    const auto key = win32::translate_keycode(keyboard);

    // ignore keys other than those on 101 keyboard
    if(key == InputAxis::UNKNOWN)
        return false;

    auto &archetype = inserter.archetype();

    // todo: timestamp

    auto &evt = archetype.component<ComponentInputEvent>();
    const auto pressed = (keyboard.Flags & RI_KEY_BREAK) == 0;
    evt.axis = key;
    evt.absolute = { 0, pressed };
    evt.relative = { 0, pressed ? 1 : -1 };

    inserter.insert();

    return true;
}

bool InputEventSourceWin32RawInput::raw_input__handle_mouse(
    InputEventInserter &inserter,
    const tagRAWMOUSE &mouse,
    const win32::MessageInfo &info)
{
    // todo: timestamp


    [[maybe_unused]]
    static Vector2f last_position;

    auto &archetype = inserter.archetype();
    auto &event = archetype.component<ComponentInputEvent>();
    auto &time = archetype.component<ComponentTimestamp>();

    time.seconds = mSink->tick_to_clock(info.time).count();

    Vector2f cursor_rel;
    const Vector2f cursor_abs = { info.cursor.x, info.cursor.y };

    // if the mouse position is absolute (e.g. sent by remote desktop software)
    // convert them to relative. note that typically only relative positions
    // are generated by windows.
    // see https://stackoverflow.com/questions/14113303/raw-input-device-rawmouse-usage
    if(mouse.usFlags & MOUSE_MOVE_ABSOLUTE)
    {
        assert(mouse.usFlags & MOUSE_VIRTUAL_DESKTOP);

        // when using remote desktop, the coordinates of mouse cursor ranges
        // from 0~65535 which covers the screen, a conversion using screen
        // size is therefore required.
        // see http://www.petergiuntoli.com/parsing-wm_input-over-remote-desktop
        // and https://stackoverflow.com/questions/31949476/raw-input-mouse-lastx-lasty-with-odd-values-while-logged-in-through-rdp
        // event.absolute = // screenPositionToActiveWindow(
        //     convert_from_absolute_position({ mouse.lLastX, mouse.lLastY });
        // );
        // todo the rel pos will be wrong after switching to another window
        // event.relative = abs - mLastPosition;
    }
    else
    {
        // abs = cursorPositionInActiveWindow();
        cursor_rel = { mouse.lLastX, mouse.lLastY };
    }
    last_position = cursor_abs;

    // when in GUI mode, only processes events inside the window rect
    // todo since we use raw input, we receive the mouse messages even if the
    // part of window is covered, in which case the user might perform
    // undesired actions.
    // if(!isImmersiveMode())
    // {
    //     const auto win_size = window->size();
    //     // todo process the input if any mouse button is pressed (dragging)
    //     if(abs.x() < 0 || abs.y() < 0 ||
    //         abs.x() >= win_size.x() || abs.y() >= win_size.y())
    //         return;
    // }

    // process mouse movement
    if(!cursor_rel.isZero())
    {
        event.axis = InputAxis::MOUSE_CURSOR;
        event.absolute = cursor_abs;
        event.relative = cursor_rel;
        inserter.insert();
    }

    auto btn_pressed = [&](int flag, InputAxis code) {
        if(mouse.usButtonFlags & flag)
        {
            event.axis = code;
            event.absolute = { 0, 1 };
            event.relative = { 0, 1 };
            inserter.insert();
        }
    };

    auto btn_released = [&](int flag, InputAxis code) {
        if(mouse.usButtonFlags & flag)
        {
            event.axis = code;
            event.absolute = { 0, 0 };
            event.relative = { 0, -1 };
            inserter.insert();
        }
    };
    // process mouse buttons & scrolling
    if(mouse.usButtonFlags)
    {
        // process mouse buttons
        // note that it is impossible to activate another window while holding
        // a mouse button pressed within the active window, so it is
        // unnecessary to clear button press states when deactivate the window.
        // however this is not the case for the keyboard.

        btn_pressed(RI_MOUSE_LEFT_BUTTON_DOWN, InputAxis::MOUSE_LEFT);
        btn_pressed(RI_MOUSE_MIDDLE_BUTTON_DOWN, InputAxis::MOUSE_MIDDLE);
        btn_pressed(RI_MOUSE_RIGHT_BUTTON_DOWN, InputAxis::MOUSE_RIGHT);
        btn_pressed(RI_MOUSE_BUTTON_4_DOWN, InputAxis::MOUSE_BUTTON_4);
        btn_pressed(RI_MOUSE_BUTTON_5_DOWN, InputAxis::MOUSE_BUTTON_5);

        btn_released(RI_MOUSE_LEFT_BUTTON_UP, InputAxis::MOUSE_LEFT);
        btn_released(RI_MOUSE_MIDDLE_BUTTON_UP, InputAxis::MOUSE_MIDDLE);
        btn_released(RI_MOUSE_RIGHT_BUTTON_UP, InputAxis::MOUSE_RIGHT);
        btn_released(RI_MOUSE_BUTTON_4_UP, InputAxis::MOUSE_BUTTON_4);
        btn_released(RI_MOUSE_BUTTON_5_UP, InputAxis::MOUSE_BUTTON_5);

        const auto wheel_delta = static_cast<short>(mouse.usButtonData) /
            static_cast<float>(WHEEL_DELTA);

        // process scrolling
        if(mouse.usButtonFlags & RI_MOUSE_WHEEL)
        {
            event.axis = InputAxis::MOUSE_WHEEL_Y;
            event.absolute = { 0, 0 };
            event.relative = { 0, wheel_delta };
            inserter.insert();
        }
        // horizontal scrolling, which seems to be undocumented.
        // found here: https://stackoverflow.com/questions/7942307/horizontal-mouse-wheel-messages-from-windows-raw-input
        if(mouse.usButtonFlags & RI_MOUSE_HWHEEL)
        {
            event.axis = InputAxis::MOUSE_WHEEL_X;
            event.absolute = { 0, 0 };
            event.relative = { wheel_delta, 0 };
            inserter.insert();
        }
    }

    return true;
}

InputEventSourceWin32RawInput::InputEventSourceWin32RawInput()
{
    mSink = WeakSingleton<RawInputSink>::try_lock_construct();
}

void InputEventSourceWin32RawInput::collect_events()
{
    win32::receive_messages();
}

void InputEventSourceWin32RawInput::process_events(
    InputEventInserter &input_event_sink)
{
    using namespace win32;

    auto queue = mSink->message_queue;
    auto head = reinterpret_cast<RAWINPUT*>(queue.data());
    const auto end = reinterpret_cast<std::size_t>(queue.data()) + queue.size();

    while(head && reinterpret_cast<std::size_t>(head) < end)
    {
        const auto &info = *(MessageInfo*)&head->header.wParam;

        switch(head->header.dwType)
        {
            case RIM_TYPEKEYBOARD:
                raw_input__handle_keyboard(
                    input_event_sink,
                    head->data.keyboard,
                    info
                );
                break;

            case RIM_TYPEMOUSE:
                raw_input__handle_mouse(
                    input_event_sink,
                    head->data.mouse,
                    info
                );
                break;

            case RIM_TYPEHID:
            default:
                break;
        }
        head = reinterpret_cast<RAWINPUT*>(
            reinterpret_cast<std::size_t>(head) + head->header.dwSize
        );
    }

    mSink->message_queue.clear();
}
}
